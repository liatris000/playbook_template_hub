# 再利用しやすい設計ガイド（OOPとの関係）

このドキュメントは、受託案件間でコードを使い回せるようにするための設計・運用ルールを定義します。  
結論として、主軸は「OOP かどうか」ではなく「境界・契約・依存関係」の管理です。

## まず結論

- OOP は実装スタイルの選択肢の1つ
- 再利用性はアーキテクチャ設計の課題
- TypeScript/Next では、`関数 + モジュール境界` を基本にし、必要な箇所だけクラスを使う

## OOP と再利用性の関係

### 合っている点

- OOP のカプセル化は、責務分離に役立つ
- DI しやすいクラス設計はテストや差し替えに有利

### ずれやすい点

- クラス化しただけでは再利用性は上がらない
- 継承中心の設計は、別案件差分に弱くなることがある
- 先に境界を決めずに OOP を選ぶと、横断依存が増えて再利用が難しくなる

## 再利用性を上げる設計原則

1. 境界を先に決める
   - 例: `auth`, `api-contract`, `db-access`, `ui-components`
2. 契約を先に固定する
   - API の request/response、エラー形式、ロール定義
3. 実装は後から差し替え可能にする
   - Supabase 固定ロジックをドメイン層へ漏らしすぎない
4. 依存方向を一方向にする
   - `app -> domain -> infra` は可、逆依存は不可
5. 公開 API を最小化する
   - 内部関数を export しすぎない

## 共通化の単位（推奨）

| 単位 | 例 | 再利用性 | 変更コスト |
|---|---|---|---|
| 関数単位 | `withAuth`, `toResponse` | 中 | 低 |
| モジュール単位 | `auth` ドメイン一式 | 高 | 中 |
| パッケージ単位 | `auth-kit`, `api-contracts` | 高 | 高 |

最初はモジュール単位で共通化し、複数案件で安定したらパッケージ化する。

## クラスを使うべき場面 / 使わない場面

### クラスを使う

- 状態を持つオブジェクト（キャッシュ、コネクション管理）
- 戦略差し替えが多い領域（認証プロバイダ切替など）
- ライフサイクル管理が必要な処理

### 関数で十分

- バリデーション、変換、整形
- API レスポンス組み立て
- 副作用が少ない純粋ロジック

## 管理方法（コードを使い回すための運用）

1. 共有対象を `reuse-candidates` として明示する
   - 例: `with-auth`, `permissions`, `toResponse`
2. 共有コードは「公開API」「内部API」を分ける
3. 破壊的変更はバージョンで管理する
   - 互換なし変更はメジャーアップ
4. 互換性テストをCIに入れる
   - 共有側変更時に利用側テストを実行
5. 受託案件向けテンプレに反映する
   - 新規案件はテンプレ起点で開始する

## 今すぐ導入できる最小セット

1. `auth` と `api-response` の公開APIを固定する
2. 共有候補に `owner` を設定する（責任者不在を防止）
3. PR テンプレに「再利用影響」欄を追加する
4. 共有候補変更時に `lint + test + build` を必須にする

## PR チェックリスト（再利用性）

- [ ] 新規コードの責務境界が明確
- [ ] 依存方向が逆転していない
- [ ] 公開APIが増えすぎていない
- [ ] 破壊的変更の影響範囲が明記されている
- [ ] 別案件転用時の置換ポイントが記載されている
